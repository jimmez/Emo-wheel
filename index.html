<!-- Emotional Generator v30 - Jimmy James - 07.12.2025 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emotional Generator v30 â€“ Mode 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
      background: #020617;
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: block;
      background: #020617;
    }

    .app {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      padding: 10px 14px 14px;
      position: relative;
    }

    /* WATERMARK â€“ small, no blur, fades after 5s */
    .watermark {
      position: fixed;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #9ca3af;
      opacity: 0.9;
      pointer-events: none;
      z-index: 50;
      letter-spacing: 0.08em;
      animation: watermarkFade 5s forwards;
    }

    @keyframes watermarkFade {
      0%   { opacity: 0.9; }
      80%  { opacity: 0.9; }
      100% { opacity: 0; }
    }

    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .settings-wrapper {
      margin-top: 6px;
    }

    h1 {
      font-size: 1.2rem;
      margin: 0 0 4px;
      text-align: center;
      color: #f9fafb;
    }

    .mode-label {
      text-align: center;
      font-size: 0.86rem;
      color: #9ca3af;
      margin-bottom: 6px;
    }

    .word-touch-zone {
      flex: 1;
      min-height: 55vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: stretch;
      cursor: pointer;
    }

    .word-display {
      border-radius: 18px;
      padding: 20px 18px;
      background: radial-gradient(circle at top, #1f2937, #020617);
      box-shadow: 0 12px 28px rgba(0,0,0,0.55);
      min-height: 40vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: stretch;
      transition: transform 0.08s ease, box-shadow 0.08s ease;
    }

    .word-touch-zone:active .word-display {
      transform: scale(0.98);
      box-shadow: 0 5px 16px rgba(0,0,0,0.55);
    }

    .emoji {
      font-size: 2.4rem;
      margin-bottom: 4px;
      min-height: 2.4rem;
      text-align: left;
      font-family: "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif;
    }

    .word-text {
      font-size: clamp(2.4rem, 6vw, 3.4rem);
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      word-wrap: break-word;
      text-align: left;
      line-height: 1.1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre;
    }

    .genz-slang-mode {
      color: #7dd3fc;
      font-style: italic;
      font-variant: normal;
      text-transform: lowercase;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: clamp(2.4rem, 6vw, 3.4rem);
      letter-spacing: 0.08em;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
      font-size: 0.86rem;
      color: #9ca3af;
      gap: 8px;
      flex-wrap: wrap;
    }

    .group-label {
      font-weight: 600;
      min-width: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .timer-row {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.84rem;
      color: #9ca3af;
    }

    .countdown {
      min-width: 52px;
    }

    .progress-container {
      flex: 1;
      background: #020617;
      border-radius: 999px;
      overflow: hidden;
      height: 8px;
      border: 1px solid #1f2937;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #22c55e, #eab308);
      transition: width 0.1s linear;
      margin-left: auto; /* anchor on right so it shrinks from left->right */
    }

    .top-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
      gap: 6px;
      font-size: 0.82rem;
      color: #9ca3af;
      flex-wrap: wrap;
    }

    .reveal-toggle,
    .settings-toggle,
    .phonetic-toggle {
      border-radius: 999px;
      border: 1px solid #374151;
      padding: 4px 10px;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .nav-row {
      margin-top: 6px;
      display: flex;
      gap: 8px;
    }

    .nav-btn {
      flex: 1;
      border: none;
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      background: #111827;
      color: #e5e7eb;
      box-shadow: 0 2px 6px rgba(0,0,0,0.45);
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
    }

    .nav-btn:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0.4);
    }

    .reveal-panel {
      margin-top: 6px;
      border-radius: 14px;
      padding: 8px 10px;
      background: #030712;
      border: 1px dashed #4b5563;
      display: none;
      font-size: 0.82rem;
      max-height: 35vh;
      overflow-y: auto;
    }

    .reveal-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .reveal-line {
      margin: 2px 0;
    }

    .chip-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .chip {
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid currentColor;
      font-size: 0.75rem;
    }

    .chip.current {
      font-weight: 600;
      background: rgba(255,255,255,0.06);
    }

    .settings {
      border-radius: 14px 14px 10px 10px;
      padding: 8px 10px 10px;
      background: #020617;
      border: 1px solid #1f2937;
      font-size: 0.82rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .settings.hidden {
      display: none;
    }

    .settings h2 {
      font-size: 0.86rem;
      margin: 0 0 4px;
      color: #e5e7eb;
    }

    .settings-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .settings label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      white-space: nowrap;
    }

    .settings input[type="number"] {
      width: 70px;
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      text-align: center;
      outline: none;
      font-size: 0.82rem;
    }

    .settings input[type="number"]:focus {
      border-color: #eab308;
      box-shadow: 0 0 0 1px #eab30855;
    }

    .settings input[type="checkbox"],
    .settings select {
      accent-color: #eab308;
      background: #020617;
      color: #e5e7eb;
      border-radius: 999px;
      border: 1px solid #4b5563;
      padding: 3px 8px;
      font-size: 0.8rem;
    }

    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 2px;
    }

    @media (max-width: 600px) {
      .word-display {
        min-height: 45vh;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="watermark">
      Jimmy James - 07.12.2025 - v30
    </div>

    <div class="main-area" id="mainArea">
      <h1>Emotional Generator v30</h1>
      <div class="mode-label">Mode 1 - Tap anywhere above the settings for a new word</div>

      <div class="word-touch-zone" id="wordTouchZone">
        <div id="wordArea" class="word-display">
          <div id="emoji" class="emoji"></div>
          <div id="wordText" class="word-text">â€¦</div>
        </div>

        <div class="status-row">
          <span id="groupLabel" class="group-label"></span>
          <span id="originalLabel"></span>
          <span id="categoryLabel"></span>
        </div>

        <div class="timer-row">
          <span id="countdown" class="countdown"></span>
          <div id="progressContainer" class="progress-container">
            <div id="progressBar" class="progress-bar"></div>
          </div>
        </div>

        <div class="top-controls">
          <button id="revealBtn" class="reveal-toggle">Reveal hierarchy</button>
          <button id="phoneticBtn" class="phonetic-toggle">Phonetic: OFF</button>
          <button id="fullscreenBtn" class="phonetic-toggle">Fullscreen: OFF</button>
          <button id="settingsToggleBtn" class="settings-toggle">Hide settings</button>
        </div>

        <div id="revealPanel" class="reveal-panel"></div>

        <div class="nav-row">
          <button id="prevBtn" class="nav-btn">&lt; Prev</button>
          <button id="pauseBtn" class="nav-btn">Pause ||</button>
          <button id="nextBtn" class="nav-btn">Next &gt;</button>
        </div>
      </div>
    </div>

    <div class="settings-wrapper">
      <div class="settings" id="settingsPanel">
        <h2>Settings</h2>
        <div class="settings-row">
          <label>
            Seconds / word:
            <input id="intervalInput" type="number" min="1" step="1" value="5" />
          </label>
          <label>
            Syllable speed (1â€“10):
            <input id="syllableSpeedInput" type="number" min="1" max="10" step="1" value="5" />
          </label>
          <label>
            <input id="speakToggle" type="checkbox" />
            Speak word aloud
          </label>
        </div>

        <div class="settings-row">
          <label>
            <input id="countdownToggle" type="checkbox" checked />
            Show countdown
          </label>
          <label>
            <input id="barToggle" type="checkbox" checked />
            Show progress bar
          </label>
        </div>

        <div class="settings-row">
          <label>
            <input id="syllableModeToggle" type="checkbox" />
            Syllables on separate lines
          </label>
          <label>
            <input id="fullscreenToggle" type="checkbox" />
            Fullscreen mode
          </label>
        </div>

        <div class="settings-row">
          <label>
            <input id="wholeWordToggle" type="checkbox" />
            Show whole word (no staged reveal)
          </label>
        </div>

        <div class="settings-row">
          <label for="playModeSelect">Play order:</label>
          <select id="playModeSelect">
            <option value="random">Random (default)</option>
            <option value="grouped">By group order</option>
          </select>
        </div>

        <div class="settings-row">
          <label>
            <input id="emojiToggle" type="checkbox" />
            Show emoji
          </label>
          <label>
            <input id="genZToggle" type="checkbox" />
            Gen Z slang mode
          </label>
        </div>

        <div class="hint">
          â€¢ First second: first syllable + underscores (in normal mode).<br>
          â€¢ Second: first + second syllable + underscores.<br>
          â€¢ In syllable-line mode: each syllable gets its own line (no underscores).<br>
          â€¢ Phonetic mode uses syllables that feel like speech, not spelling.<br>
          â€¢ Gen Z mode: shows slang first, then the original word at the end.
        </div>
      </div>
    </div>
  </div>

  <script>
    const EMOJI_START_FRACTION = 0.8;
    const EMOJI_PROBABILITY = 0.8;

    const EMOTION_GROUPS = [
      {
        name: "GLAD (Happy)",
        emoji: "ðŸ˜Š",
        color: "#fbbf24",
        categories: [
          { name: "Playful", emoji: "ðŸ˜Š", children: ["Aroused", "Cheeky"] },
          { name: "Content", emoji: "ðŸ™‚", children: ["Free", "Joyful"] },
          { name: "Interested", emoji: "ðŸ¤”", children: ["Curious", "Inquisitive"] },
          { name: "Proud", emoji: "ðŸ˜Œ", children: ["Successful", "Confident"] },
          { name: "Accepted", emoji: "ðŸ¤", children: ["Respected", "Valued"] },
          { name: "Powerful", emoji: "ðŸ’ª", children: ["Courageous", "Creative"] },
          { name: "Peaceful", emoji: "ðŸ•Šï¸", children: ["Loving", "Thankful"] },
          { name: "Trusting", emoji: "ðŸ¤—", children: ["Sensitive", "Intimate"] },
          { name: "Optimistic", emoji: "ðŸŒˆ", children: ["Hopeful", "Inspired"] },
        ],
      },
      {
        name: "SURPRISED",
        emoji: "ðŸ˜®",
        color: "#38bdf8",
        categories: [
          { name: "Startled", emoji: "ðŸ˜³", children: ["Shocked", "Dismayed"] },
          { name: "Confused", emoji: "ðŸ˜•", children: ["Disillusioned", "Perplexed"] },
          { name: "Amazed", emoji: "ðŸ¤©", children: ["Astonished", "Awe"] },
          { name: "Excited", emoji: "ðŸ˜ƒ", children: ["Eager", "Energetic"] },
        ],
      },
      {
        name: "BAD (Angry)",
        emoji: "ðŸ˜¡",
        color: "#f97316",
        categories: [
          { name: "Let down", emoji: "ðŸ˜ž", children: ["Betrayed", "Resentful"] },
          { name: "Humiliated", emoji: "ðŸ˜³", children: ["Disrespected", "Ridiculed"] },
          { name: "Bitter", emoji: "ðŸ¥µ", children: ["Indignant", "Violated"] },
          { name: "Mad", emoji: "ðŸ¤¬", children: ["Furious", "Jealous"] },
          { name: "Aggressive", emoji: "ðŸ—¯ï¸", children: ["Provoked", "Hostile"] },
          { name: "Frustrated", emoji: "ðŸ˜ ", children: ["Infuriated", "Annoyed"] },
          { name: "Distant", emoji: "ðŸ˜¶", children: ["Withdrawn", "Numb"] },
          { name: "Critical", emoji: "ðŸ˜’", children: ["Sceptical", "Dismissive"] },
        ],
      },
      {
        name: "DISGUSTED",
        emoji: "ðŸ¤¢",
        color: "#22c55e",
        categories: [
          { name: "Disapproving", emoji: "ðŸ™…", children: ["Judgmental", "Embarrassed"] },
          { name: "Disappointed", emoji: "ðŸ˜£", children: ["Appalled", "Revolted"] },
          { name: "Awful", emoji: "ðŸ’€", children: ["Nauseated", "Detestable"] },
          { name: "Repelled", emoji: "ðŸ˜–", children: ["Horrified", "Hesitant"] },
        ],
      },
      {
        name: "SAD",
        emoji: "ðŸ˜”",
        color: "#6366f1",
        categories: [
          { name: "Lonely", emoji: "ðŸ˜”", children: ["Isolated", "Abandoned"] },
          { name: "Vulnerable", emoji: "â­•", children: ["Victimised", "Fragile"] },
          { name: "Despair", emoji: "ðŸŒ§ï¸", children: ["Grief", "Powerless"] },
          { name: "Guilty", emoji: "ðŸ˜“", children: ["Remorseful", "Ashamed"] },
          { name: "Depressed", emoji: "ðŸŒ«ï¸", children: ["Empty", "Inferior"] },
          { name: "Hurt", emoji: "ðŸ’”", children: ["Embarrassed", "Disappointed"] },
        ],
      },
      {
        name: "BAD (low mood)",
        emoji: "ðŸ˜•",
        color: "#e11d48",
        categories: [
          { name: "Tired", emoji: "ðŸ˜´", children: ["Sleepy", "Unfocused"] },
          { name: "Stressed", emoji: "ðŸ˜«", children: ["Overwhelmed", "Out of control"] },
          { name: "Busy", emoji: "ðŸ˜°", children: ["Rushed", "Pressured"] },
          { name: "Bored", emoji: "ðŸ˜", children: ["Indifferent", "Apathetic"] },
        ],
      },
      {
        name: "AFRAID (Fearful)",
        emoji: "ðŸ˜¨",
        color: "#06b6d4",
        categories: [
          { name: "Scared", emoji: "ðŸ˜±", children: ["Helpless", "Frightened"] },
          { name: "Anxious", emoji: "ðŸ˜Ÿ", children: ["Overwhelmed", "Worried"] },
          { name: "Insecure", emoji: "ðŸ˜¬", children: ["Inadequate", "Inferior"] },
          { name: "Weak", emoji: "ðŸ˜ž", children: ["Worthless", "Insignificant"] },
          { name: "Rejected", emoji: "ðŸš«", children: ["Excluded", "Persecuted"] },
          { name: "Threatened", emoji: "âš ï¸", children: ["Nervous", "Exposed"] },
        ],
      },
    ];

    // phonetic override / heuristic
    const PHONETIC_OVERRIDES = {
      "CURIOUS": ["CU", "RI", "OUS"],
      "DETACHED": ["DE", "TACH", "ED"],
      "LONELY": ["LONE", "LY"],
      "AMAZED": ["a", "Maze", "d"],
      "AWESOME": ["Awe", "some"],
      "EXCITED": ["Ex", "Ci", "Ted"],
      "RIDICULED": ["Rid", "i", "culed"],
      "SCARED": ["Scar", "ed"],
      "SCEPTICAL": ["Scep", "tic", "al"],
      "HESITANT": ["Hes", "it", "ant"],
      "HELPLESS": ["help", "less"]
    };

    // Simple Gen Z slang mapping; fallback will add " (no cap)"
    function getGenZWord(base) {
      const upper = base.trim().toUpperCase();
      const map = {
        "GLAD": "vibing",
        "PLAYFUL": "goofy mode",
        "AROUSED": "super hyped",
        "CHEEKY": "cheeky af",
        "CONTENT": "chill",
        "FREE": "unlocked",
        "JOYFUL": "big happy",
        "INTERESTED": "low-key curious",
        "CURIOUS": "curious cat",
        "INQUISITIVE": "asking all the things",
        "PROUD": "feeling myself",
        "SUCCESSFUL": "winning",
        "CONFIDENT": "built different",
        "ACCEPTED": "in the group chat",
        "RESPECTED": "getting their flowers",
        "VALUED": "main character energy",
        "POWERFUL": "OP",
        "COURAGEOUS": "no fear",
        "CREATIVE": "brain in HD",
        "PEACEFUL": "zen mode",
        "LOVING": "full heart",
        "THANKFUL": "gratitude vibes",
        "TRUSTING": "open book",
        "SENSITIVE": "soft era",
        "INTIMATE": "close-close",
        "OPTIMISTIC": "delulu in a good way",
        "HOPEFUL": "hope core",
        "INSPIRED": "ideas on 100",
        "STARTLED": "jump scare",
        "SHOCKED": "shook",
        "DISMAYED": "big yikes",
        "CONFUSED": "what is happening",
        "DISILLUSIONED": "over it",
        "PERPLEXED": "brain loading",
        "AMAZED": "mind blown",
        "ASTONISHED": "speechless fr",
        "AWE": "jaw dropped",
        "EXCITED": "hyped up",
        "EAGER": "cannot wait",
        "ENERGETIC": "zoomies",
        "LET DOWN": "meh now",
        "BETRAYED": "backstabbed",
        "RESENTFUL": "salty",
        "HUMILIATED": "instant log off",
        "DISRESPECTED": "no respect vibes",
        "RIDICULED": "clowned",
        "BITTER": "pressed",
        "INDIGNANT": "so done",
        "VIOLATED": "not okay",
        "MAD": "big mad",
        "FURIOUS": "rage mode",
        "JEALOUS": "jealous much",
        "AGGRESSIVE": "ready to fight",
        "PROVOKED": "they asked for it",
        "HOSTILE": "on edge",
        "FRUSTRATED": "stuck af",
        "INFURIATED": "rage quit",
        "ANNOYED": "over it tbh",
        "DISTANT": "ghost mode",
        "WITHDRAWN": "off the grid",
        "NUMB": "no feelings rn",
        "CRITICAL": "side-eyeing",
        "SCEPTICAL": "sus",
        "DISMISSIVE": "nah",
        "DISAPPROVING": "not it",
        "JUDGMENTAL": "judgy",
        "EMBARRASSED": "second-hand cringe",
        "DISAPPOINTED": "low-key crushed",
        "APPALLED": "absolutely not",
        "REVOLTED": "hard pass",
        "AWFUL": "trash vibes",
        "NAUSEATED": "feeling ick",
        "DETESTABLE": "hard nope",
        "REPELLED": "instant ick",
        "HORRIFIED": "nightmare fuel",
        "HESITANT": "hmm idk",
        "LONELY": "solo core",
        "ISOLATED": "off the map",
        "ABANDONED": "left on read",
        "VULNERABLE": "no armor",
        "VICTIMISED": "done dirty",
        "FRAGILE": "handle with care",
        "DESPAIR": "zero hope",
        "GRIEF": "heavy heart",
        "POWERLESS": "buttons smashed",
        "GUILTY": "my bad fr",
        "REMORSEFUL": "wish I could undo",
        "ASHAMED": "hide mode",
        "DEPRESSED": "low battery",
        "EMPTY": "no signal",
        "INFERIOR": "background character",
        "HURT": "hit different",
        "TIRED": "running on fumes",
        "SLEEPY": "need nap asap",
        "UNFOCUSED": "brain tab overload",
        "STRESSED": "too much rn",
        "OVERWHELMED": "buffering",
        "OUT OF CONTROL": "off the rails",
        "BUSY": "calendar crying",
        "RUSHED": "speedrun life",
        "PRESSURED": "under the thumb",
        "BORED": "dead vibes",
        "INDIFFERENT": "mid",
        "APATHETIC": "no thoughts",
        "SCARED": "spooked",
        "HELPLESS": "hands tied",
        "FRIGHTENED": "heart racing",
        "ANXIOUS": "nerves on max",
        "WORRIED": "what if brain",
        "INSECURE": "questioning everything",
        "INADEQUATE": "not enough",
        "WEAK": "low power mode",
        "WORTHLESS": "no value feels",
        "INSIGNIFICANT": "tiny spec",
        "REJECTED": "benched",
        "EXCLUDED": "not invited",
        "PERSECUTED": "targeted",
        "THREATENED": "danger vibes",
        "NERVOUS": "butterflies",
        "EXPOSED": "too seen"
      };
      return map[upper] || (base + " (no cap)");
    }

    const ALL_WORDS = [];
    EMOTION_GROUPS.forEach((group, gi) => {
      ALL_WORDS.push({
        type: "group",
        displayWord: group.name.replace(/\s*\(.*?\)/, ""),
        groupIndex: gi,
        categoryIndex: null,
        childIndex: null,
        group,
        category: null
      });

      group.categories.forEach((cat, ci) => {
        ALL_WORDS.push({
          type: "category",
          displayWord: cat.name,
          groupIndex: gi,
          categoryIndex: ci,
          childIndex: null,
          group,
          category: cat
        });

        cat.children.forEach((word, wi) => {
          ALL_WORDS.push({
            type: "leaf",
            displayWord: word,
            groupIndex: gi,
            categoryIndex: ci,
            childIndex: wi,
            group,
            category: cat
          });
        });
      });
    });

    const wordTouchZone = document.getElementById("wordTouchZone");
    const emojiEl = document.getElementById("emoji");
    const wordTextEl = document.getElementById("wordText");
    const groupLabelEl = document.getElementById("groupLabel");
    const originalLabelEl = document.getElementById("originalLabel");
    const categoryLabelEl = document.getElementById("categoryLabel");
    const countdownEl = document.getElementById("countdown");
    const progressContainerEl = document.getElementById("progressContainer");
    const progressBarEl = document.getElementById("progressBar");
    const revealBtn = document.getElementById("revealBtn");
    const revealPanel = document.getElementById("revealPanel");
    const settingsToggleBtn = document.getElementById("settingsToggleBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const intervalInput = document.getElementById("intervalInput");
    const syllableSpeedInput = document.getElementById("syllableSpeedInput");
    const speakToggle = document.getElementById("speakToggle");
    const countdownToggle = document.getElementById("countdownToggle");
    const barToggle = document.getElementById("barToggle");
    const syllableModeToggle = document.getElementById("syllableModeToggle");
    const fullscreenToggle = document.getElementById("fullscreenToggle");
    const wholeWordToggle = document.getElementById("wholeWordToggle");
    const playModeSelect = document.getElementById("playModeSelect");
    const phoneticBtn = document.getElementById("phoneticBtn");
    const emojiToggle = document.getElementById("emojiToggle");
    const genZToggle = document.getElementById("genZToggle");

    const MODE_RANDOM = "random";
    const MODE_GROUPED = "grouped";

    let playMode = MODE_RANDOM;
    let navOrder = [];
    let navPos = 0;

    let currentIndex = 0;
    let currentEntry = ALL_WORDS[0];
    let currentParts = [];
    let currentBaseWord = "";
    let showEmojiForWord = true;
    let phoneticMode = false;

    let intervalSeconds = parseFloat(intervalInput.value) || 5;
    let syllableSpeedLevel = parseInt(syllableSpeedInput.value, 10) || 5;
    let syllableVisibleCount = 1;
    let timerHandle = null;
    let isPaused = false;
    let startTimestamp = null;
    let accumulatedMs = 0;
    let lastStage = 1;

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function buildNavOrder(keepCurrentIndex) {
      const total = ALL_WORDS.length;
      if (playMode === MODE_RANDOM) {
        const indices = Array.from({ length: total }, (_, i) => i);
        if (keepCurrentIndex) {
          const current = currentIndex;
          const rest = indices.filter(i => i !== current);
          shuffleArray(rest);
          navOrder = [current, ...rest];
          navPos = 0;
        } else {
          shuffleArray(indices);
          navOrder = indices;
          navPos = 0;
        }
      } else {
        navOrder = Array.from({ length: total }, (_, i) => i);
        if (keepCurrentIndex) {
          const pos = navOrder.indexOf(currentIndex);
          navPos = pos >= 0 ? pos : 0;
        } else {
          navPos = 0;
        }
      }
    }

    function mapSyllableLevelToSeconds(level) {
      const rounded = Math.round(level);
      // 5 = base (1.0s per syllable)
      // 10 = very fast  -> ~0.2s
      // 1 = very slow   -> ~2.0s
      // Keep earlier 2â€“7 mappings and extend to 1,8,9,10.
      if (rounded <= 1) return 2.0;   // very slow
      if (rounded === 2) return 1.8;
      if (rounded === 3) return 1.4;
      if (rounded === 4) return 1.2;
      if (rounded === 5) return 1.0;
      if (rounded === 6) return 0.8;
      if (rounded === 7) return 0.6;
      if (rounded === 8) return 0.5;
      if (rounded === 9) return 0.3;
      return 0.2; // 10 and above: very fast
    }

    function phoneticSplit(word) {
      const trimmed = word.trim();
      const upper = trimmed.toUpperCase();
      if (PHONETIC_OVERRIDES[upper]) return PHONETIC_OVERRIDES[upper];

      const tokens = trimmed.split(/\s+/);
      const syllables = [];
      const vowels = "AEIOUYaeiouy";

      tokens.forEach(token => {
        if (token.length <= 3) {
          syllables.push(token);
          return;
        }
        let current = token[0];
        for (let i = 1; i < token.length; i++) {
          const ch = token[i];
          const prev = token[i - 1];
          const isVowel = vowels.includes(ch);
          const prevIsVowel = vowels.includes(prev);
          if (!prevIsVowel && isVowel) {
            syllables.push(current);
            current = ch;
          } else {
            current += ch;
          }
        }
        if (current) syllables.push(current);
      });
      return syllables;
    }

    function getSyllableParts(word, usePhonetic) {
      const trimmed = word.trim();
      const upper = trimmed.toUpperCase();

      // In Gen Z mode, split slang into word-like chunks (spaces, slashes, hyphens),
      // so pieces feel like mini-words: e.g. "low-key curious" -> ["low", "key", "curious"]
      if (genZToggle && genZToggle.checked) {
        if (!trimmed) return [];
        return trimmed.split(/[\s\/\-]+/);
      }

      if (usePhonetic) return phoneticSplit(word);
      if (PHONETIC_OVERRIDES[upper]) return PHONETIC_OVERRIDES[upper];
      const len = trimmed.length;
      if (len <= 3) return [trimmed];
      const cut1 = Math.floor(len / 3);
      const cut2 = Math.floor((len * 2) / 3);
      return [trimmed.slice(0, cut1), trimmed.slice(cut1, cut2), trimmed.slice(cut2)];
    }

    function speakWord(text) {
      if (!("speechSynthesis" in window)) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utter);
    }

    function requestFullscreenIfNeeded() {
      if (!fullscreenToggle.checked) return;
      if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    }

    function updateSettingsVisibility() {
      countdownEl.style.display = countdownToggle.checked ? "inline" : "none";
      progressContainerEl.style.display = barToggle.checked ? "block" : "none";
    }

    function updatePauseButton() {
      pauseBtn.textContent = isPaused ? "Play >" : "Pause ||";
    }

    function updateFullscreenButton() {
      if (!fullscreenBtn) return;
      fullscreenBtn.textContent = fullscreenToggle.checked ? "Fullscreen: ON" : "Fullscreen: OFF";
    }

    function updateGenZStyle() {
      if (genZToggle.checked) {
        wordTextEl.classList.add("genz-slang-mode");
        // let CSS set color (light blue)
        wordTextEl.style.color = "";
      } else {
        wordTextEl.classList.remove("genz-slang-mode");
      }
    }

    function renderStaticInfo() {
      const { group, category } = currentEntry;
      const genZMode = genZToggle.checked;
      const original = currentEntry.displayWord;

      groupLabelEl.textContent = group.emoji + " " + group.name;
      groupLabelEl.style.color = group.color;

      // Original word label in the center (Gen Z mode only)
      if (genZMode) {
        originalLabelEl.textContent = original;
        originalLabelEl.style.color = group.color;
      } else {
        originalLabelEl.textContent = "";
      }

      // Only force group color on main word when Gen Z mode is OFF;
      // when Gen Z is ON, CSS (.genz-slang-mode) controls the light-blue color.
      if (!genZMode) {
        wordTextEl.style.color = group.color;
      } else {
        wordTextEl.style.color = "";
      }

      document.getElementById("wordArea").style.border = "1px solid " + group.color;

      if (category) {
        const catEmoji = category.emoji ? category.emoji + " " : "";
        categoryLabelEl.textContent = catEmoji + category.name;
      } else {
        categoryLabelEl.textContent = "";
      }
    }

    function renderHierarchy() {
      const { group, category, displayWord, type } = currentEntry;
      revealPanel.innerHTML = "";

      const title = document.createElement("div");
      title.className = "reveal-title";
      title.textContent = "Hierarchy for this word";
      revealPanel.appendChild(title);

      const groupLine = document.createElement("div");
      groupLine.className = "reveal-line";
      groupLine.style.color = group.color;
      groupLine.textContent = group.emoji + " Group (primary): " + group.name;
      revealPanel.appendChild(groupLine);

      if (type !== "group" && category) {
        const parentLine = document.createElement("div");
        parentLine.className = "reveal-line";
        parentLine.textContent = (category.emoji ? category.emoji + " " : "") + "Secondary: " + category.name;
        revealPanel.appendChild(parentLine);
      }

      if (type === "leaf" && category) {
        const childCurrent = document.createElement("div");
        childCurrent.className = "reveal-line";
        childCurrent.textContent = "Tertiary (this word): " + displayWord;
        revealPanel.appendChild(childCurrent);

        const childrenLabel = document.createElement("div");
        childrenLabel.className = "reveal-line";
        childrenLabel.textContent = "Family (siblings):";
        revealPanel.appendChild(childrenLabel);

        const chipRow = document.createElement("div");
        chipRow.className = "chip-row";
        category.children.forEach((child) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.style.color = group.color;
          chip.textContent = child;
          if (child === displayWord) chip.classList.add("current");
          chipRow.appendChild(chip);
        });
        revealPanel.appendChild(chipRow);
      } else if (type === "category" && category) {
        const secLine = document.createElement("div");
        secLine.className = "reveal-line";
        secLine.textContent = "Secondary emotion: " + displayWord;
        revealPanel.appendChild(secLine);

        const childrenLabel = document.createElement("div");
        childrenLabel.className = "reveal-line";
        childrenLabel.textContent = "Tertiary children:";
        revealPanel.appendChild(childrenLabel);

        const chipRow = document.createElement("div");
        chipRow.className = "chip-row";
        category.children.forEach((child) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.style.color = group.color;
          chip.textContent = child;
          chipRow.appendChild(chip);
        });
        revealPanel.appendChild(chipRow);
      } else if (type === "group") {
        const secLabel = document.createElement("div");
        secLabel.className = "reveal-line";
        secLabel.textContent = "Secondary emotions in this group:";
        revealPanel.appendChild(secLabel);

        const chipRow = document.createElement("div");
        chipRow.className = "chip-row";
        group.categories.forEach((cat) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.style.color = group.color;
          chip.textContent = (cat.emoji ? cat.emoji + " " : "") + cat.name;
          chipRow.appendChild(chip);
        });
        revealPanel.appendChild(chipRow);
      }
    }

    function renderWordStage(stage, elapsedSec) {
      const parts = currentParts;
      const totalParts = parts.length;
      const multi = syllableModeToggle.checked;
      const genZMode = genZToggle.checked;
      const original = currentEntry.displayWord;
      const base = currentBaseWord;
      const whole = wholeWordToggle.checked;

      let textLines = [];
      let emojiForLine = null;

      const fraction = elapsedSec / intervalSeconds;
      if (fraction >= EMOJI_START_FRACTION && showEmojiForWord && emojiToggle.checked) {
        const { group, category } = currentEntry;
        emojiForLine = (category && category.emoji) || group.emoji;
      }

      // Whole-word mode: always show the complete word from the start
      if (whole) {
        if (multi) {
          textLines = parts.slice();
          if (emojiForLine) {
            textLines.push(emojiForLine);
          }
          wordTextEl.textContent = textLines.join("\n");
          emojiEl.textContent = "";
        } else {
          let displayText;
          if (genZMode) {
            displayText = parts.join(" ");
          } else {
            displayText = parts.join("");
          }
          wordTextEl.textContent = displayText;
          emojiEl.textContent = emojiForLine || "";
        }
        return;
      }

      if (multi) {
        // In syllable-line mode, use syllableVisibleCount when not in whole-word mode.
        if (!whole) {
          const count = Math.max(1, Math.min(syllableVisibleCount, totalParts));
          textLines = parts.slice(0, count);
        } else {
          // whole-word + multi: just show full word
          textLines = parts.slice();
        }

        if (stage >= 3 && emojiForLine) {
          textLines.push(emojiForLine);
        }

        wordTextEl.textContent = textLines.join("\n");
        emojiEl.textContent = "";
      } else {
        let visibleCount;
        if (!whole) {
          // Use syllableVisibleCount driven by syllable speed
          visibleCount = Math.max(1, Math.min(syllableVisibleCount, totalParts));
        } else {
          if (stage === 1) visibleCount = 1;
          else if (stage === 2) visibleCount = 2;
          else visibleCount = totalParts;
        }
        if (visibleCount > totalParts) visibleCount = totalParts;

        const visibleParts = parts.slice(0, visibleCount);
        const remainingParts = parts.slice(visibleCount);

        let displayText;
        if (genZMode) {
          const visibleStr = visibleParts.join(" ");
          const remainingStr = remainingParts.join(" ");
          if (stage < 3) {
            const underscoreBlocks = remainingParts.map(p => "_".repeat(p.length));
            const underscoreStr = underscoreBlocks.join(" ");
            displayText = visibleStr + (underscoreStr ? (visibleStr ? " " : "") + underscoreStr : "");
          } else {
            displayText = parts.join(" ");
          }
        } else {
          const visible = visibleParts.join("");
          const remaining = remainingParts.join("");
          if (stage < 3) {
            displayText = visible + (remaining.length > 0 ? "_".repeat(remaining.length) : "");
          } else {
            displayText = parts.join("");
          }
        }
        wordTextEl.textContent = displayText;
        emojiEl.textContent = emojiForLine || "";
      }
    }

    function resetTimers() {
      if (timerHandle) {
        clearInterval(timerHandle);
        timerHandle = null;
      }
      isPaused = false;
      accumulatedMs = 0;
      startTimestamp = Date.now();
      lastStage = 1;
      updatePauseButton();

      if (barToggle.checked) {
        progressContainerEl.style.display = "block";
        progressBarEl.style.width = "100%";
      } else {
        progressContainerEl.style.display = "none";
      }

      if (countdownToggle.checked) {
        countdownEl.textContent = intervalSeconds + " s";
      }

      renderWordStage(1, 0);

      timerHandle = setInterval(tick, 100);
    }

    function tick() {
      if (isPaused) return;

      const now = Date.now();
      const elapsedMs = accumulatedMs + (now - startTimestamp);
      const elapsedSec = elapsedMs / 1000;
      const totalSec = intervalSeconds;
      const remainingSec = Math.max(0, totalSec - elapsedSec);

      if (elapsedSec >= totalSec) {
        nextWord();
        return;
      }

      const multi = syllableModeToggle.checked;
      const whole = wholeWordToggle.checked;
      let stage = 1;

      if (!whole) {
        // Use syllable speed for how quickly new syllables/chunks appear,
        // for both multi-line and single-line reveal modes.
        const partsCount = currentParts.length || 1;
        let syllSec = mapSyllableLevelToSeconds(syllableSpeedLevel);

        if (syllSec * partsCount > totalSec && totalSec > 0) {
          syllSec = totalSec / partsCount;
        }

        const visible = Math.min(partsCount, Math.floor(elapsedSec / syllSec) + 1);
        syllableVisibleCount = visible;

        stage = (visible >= partsCount) ? 3 : (visible >= 2 ? 2 : 1);
      } else {
        // Whole-word mode: keep a simple 3-phase notion just for speech timing.
        const fraction = totalSec > 0 ? (elapsedSec / totalSec) : 0;
        if (fraction < 1 / 3) stage = 1;
        else if (fraction < 2 / 3) stage = 2;
        else stage = 3;
      }

      renderWordStage(stage, elapsedSec);

      if (stage === 3 && lastStage !== 3 && speakToggle.checked) {
        speakWord(currentEntry.displayWord);
      }
      lastStage = stage;

      if (countdownToggle.checked) {
        const display = Math.max(0, Math.ceil(remainingSec));
        countdownEl.textContent = display + " s";
      }

      if (barToggle.checked) {
        if (remainingSec <= 0 || totalSec <= 0) {
          progressContainerEl.style.display = "none";
        } else {
          const pct = Math.min(100, Math.max(0, (remainingSec / totalSec) * 100));
          progressContainerEl.style.display = "block";
          progressBarEl.style.width = pct + "%";
        }
      }
    }

    function pauseTimer() {
      if (isPaused) return;
      isPaused = true;
      if (startTimestamp != null) {
        accumulatedMs += Date.now() - startTimestamp;
      }
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
      updatePauseButton();
    }

    function resumeTimer() {
      if (!isPaused) return;
      isPaused = false;
      startTimestamp = Date.now();
      updatePauseButton();
    }

    function applyWord(entry) {
      currentEntry = entry;
      const genZMode = genZToggle.checked;
      const baseWord = genZMode ? getGenZWord(entry.displayWord) : entry.displayWord;
      currentBaseWord = baseWord;
      currentParts = getSyllableParts(baseWord, phoneticMode);
      showEmojiForWord = Math.random() < EMOJI_PROBABILITY;
      syllableVisibleCount = 1; // start each new word from first syllable/chunk
      renderStaticInfo();
      renderHierarchy();
      resetTimers();
    }

    function applyWordByNavPos() {
      const idx = navOrder[navPos];
      currentIndex = idx;
      applyWord(ALL_WORDS[idx]);
    }


    function stepNextSyllableOrWord() {
      const whole = wholeWordToggle.checked;
      if (whole) {
        nextWord();
        pauseTimer();
        return;
      }
      const totalParts = currentParts.length || 1;
      if (syllableVisibleCount < totalParts) {
        syllableVisibleCount++;
        let stage = (syllableVisibleCount >= totalParts) ? 3 : (syllableVisibleCount >= 2 ? 2 : 1);
        lastStage = stage;
        const elapsedForEmoji = stage === 3 ? intervalSeconds * EMOJI_START_FRACTION : 0;
        renderWordStage(stage, elapsedForEmoji);
      } else {
        nextWord();
        pauseTimer();
      }
    }

    function stepPrevSyllableOrWord() {
      const whole = wholeWordToggle.checked;
      if (whole) {
        prevWord();
        pauseTimer();
        return;
      }
      if (syllableVisibleCount > 1) {
        syllableVisibleCount--;
        let stage = (syllableVisibleCount >= currentParts.length) ? 3 : (syllableVisibleCount >= 2 ? 2 : 1);
        lastStage = stage;
        const elapsedForEmoji = stage === 3 ? intervalSeconds * EMOJI_START_FRACTION : 0;
        renderWordStage(stage, elapsedForEmoji);
      } else {
        prevWord();
        pauseTimer();
      }
    }

    function nextWord() {
      navPos = (navPos + 1) % navOrder.length;
      applyWordByNavPos();
    }

    function prevWord() {
      navPos = (navPos - 1 + navOrder.length) % navOrder.length;
      applyWordByNavPos();
    }

    wordTouchZone.addEventListener("click", () => {
      requestFullscreenIfNeeded();
      if (isPaused) {
        stepNextSyllableOrWord();
      } else {
        nextWord();
      }
    });

    nextBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      requestFullscreenIfNeeded();
      if (isPaused) {
        stepNextSyllableOrWord();
      } else {
        nextWord();
      }
    });

    prevBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      requestFullscreenIfNeeded();
      if (isPaused) {
        stepPrevSyllableOrWord();
      } else {
        prevWord();
      }
    });

    pauseBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (isPaused) {
        resumeTimer();
      } else {
        pauseTimer();
      }
    });

    revealBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = revealPanel.style.display === "block";
      if (isOpen) {
        revealPanel.style.display = "none";
        revealBtn.textContent = "Reveal hierarchy";
        resumeTimer();
      } else {
        renderHierarchy();
        revealPanel.style.display = "block";
        revealBtn.textContent = "Hide hierarchy";
        pauseTimer();
      }
    });

    settingsToggleBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const isHidden = settingsPanel.classList.contains("hidden");
      if (isHidden) {
        settingsPanel.classList.remove("hidden");
        settingsToggleBtn.textContent = "Hide settings";
      } else {
        settingsPanel.classList.add("hidden");
        settingsToggleBtn.textContent = "Show settings";
      }
    });

    intervalInput.addEventListener("focus", (e) => {
      e.target.select();
    });

    function applyIntervalFromInput() {
      const val = parseInt(intervalInput.value, 10);
      if (!isNaN(val) && val >= 1) {
        intervalSeconds = val;
        intervalInput.value = String(val);
      } else {
        intervalSeconds = 5;
        intervalInput.value = "5";
      }
      resetTimers();
    }

    intervalInput.addEventListener("change", applyIntervalFromInput);
    intervalInput.addEventListener("blur", applyIntervalFromInput);
    intervalInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        intervalInput.blur();
      }
    });

    function applySyllableSpeedFromInput() {
      const val = parseInt(syllableSpeedInput.value, 10);
      if (!isNaN(val)) {
        syllableSpeedLevel = val;
        if (syllableSpeedLevel < 1) syllableSpeedLevel = 1;
        if (syllableSpeedLevel > 10) syllableSpeedLevel = 10;
        syllableSpeedInput.value = String(syllableSpeedLevel);
      } else {
        syllableSpeedLevel = 5;
        syllableSpeedInput.value = "5";
      }
      // No full reset; tick will pick up the new speed.
    }

    syllableSpeedInput.addEventListener("focus", (e) => {
      e.target.select();
    });
    syllableSpeedInput.addEventListener("change", applySyllableSpeedFromInput);
    syllableSpeedInput.addEventListener("blur", applySyllableSpeedFromInput);
    syllableSpeedInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        syllableSpeedInput.blur();
      }
    });

    countdownToggle.addEventListener("change", () => {
      updateSettingsVisibility();
    });

    barToggle.addEventListener("change", () => {
      updateSettingsVisibility();
      resetTimers();
    });

    syllableModeToggle.addEventListener("change", () => {
      currentParts = getSyllableParts(currentBaseWord, phoneticMode);
      renderWordStage(lastStage, 0);
    });

    fullscreenToggle.addEventListener("change", () => {
      if (!fullscreenToggle.checked && document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }
      updateFullscreenButton();
    });

    phoneticBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      phoneticMode = !phoneticMode;
      phoneticBtn.textContent = phoneticMode ? "Phonetic: ON" : "Phonetic: OFF";
      currentParts = getSyllableParts(currentBaseWord, phoneticMode);
      renderWordStage(lastStage, 0);
    });

    fullscreenBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      fullscreenToggle.checked = !fullscreenToggle.checked;
      updateFullscreenButton();
      if (fullscreenToggle.checked) {
        requestFullscreenIfNeeded();
      } else if (document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }
    });

    wholeWordToggle.addEventListener("change", () => {
      renderWordStage(lastStage, 0);
    });

    emojiToggle.addEventListener("change", () => {
      renderWordStage(lastStage, 0);
    });

    genZToggle.addEventListener("change", () => {
      // Recompute base word & parts for current entry
      updateGenZStyle();
      applyWord(currentEntry);
    });

    playModeSelect.addEventListener("change", () => {
      const newMode = playModeSelect.value === "grouped" ? MODE_GROUPED : MODE_RANDOM;
      playMode = newMode;
      buildNavOrder(true);
    });


    // Keyboard controls for PC:
    // Space: toggle pause/play
    // Enter: next word (regardless of pause state)
    // ArrowRight: in pause -> next syllable (then next word), in play -> next word
    // ArrowLeft:  in pause -> previous syllable (or previous word), in play -> previous word
    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (isPaused) {
          resumeTimer();
        } else {
          pauseTimer();
        }
      } else if (e.code === "Enter") {
        e.preventDefault();
        nextWord();
      } else if (e.code === "ArrowRight") {
        e.preventDefault();
        if (isPaused) {
          stepNextSyllableOrWord();
        } else {
          nextWord();
        }
      } else if (e.code === "ArrowLeft") {
        e.preventDefault();
        if (isPaused) {
          stepPrevSyllableOrWord();
        } else {
          prevWord();
        }
      }
      updatePauseButton();
    });

    updateSettingsVisibility();
    updateGenZStyle();
    updateFullscreenButton();
    buildNavOrder(false);
    applyWordByNavPos();
  </script>
</body>
</html>
